-- DATA DICTIONARY (오라클에 관한 것)
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_VIEWS;

-- 가상뷰 내용 확인하기
DROP VIEW VIEW_EMP01;
CREATE VIEW VIEW_EMP01 AS SELECT EMPNO, EMP_NAME, EMP_JOB, DEP_ID
FROM EMP01 ORDER BY EMPNO ASC;
SELECT TEXT FROM USER_VIEWS WHERE VIEW_NAME = 'VIEW_EMP01';
SELECT * FROM VIEW_EMP01;
SELECT * FROM EMP01;
-- 가상뷰에 데이터를 입력
INSERT INTO VIEW_EMP01 VALUES (201, 'KDJ', 'IT_DEV', '80');
SELECT * FROM VIEW_EMP01;
DELETE FROM VIEW_EMP01 WHERE EMPNO = 201;
-- 가상뷰 VIEW_SALARY 실제 테이블( 부서별 총월급합계, 전체평균금액, 인원수)
DROP VIEW VIEW_SALARY;
CREATE OR REPLACE VIEW VIEW_SALARY
AS
SELECT DEPARTMENT_ID, SUM(SALARY) TOTAL_SALARY, ROUND(AVG(SALARY),1) AVG_SALARY, COUNT(*) TOTAL_COUNT 
FROM EMPLOYEES GROUP BY DEPARTMENT_ID ORDER BY DEPARTMENT_ID ASC;
SELECT * FROM VIEW_SALARY;

-- EMPLOYEES, DEPARTMENTS 두 테이블을 조인(INNER JOIN)해서, 아이디, 이름, 부서아이디, 부서명 출력하되
-- 부서 아이디로 내림차순으로 정렬하시오
DROP VIEW VIEW_EMP_DEPT;
CREATE VIEW VIEW_EMP_DEPT
AS
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D 
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID 
ORDER BY DEPARTMENT_ID DESC;
SELECT * FROM VIEW_EMP_DEPT;

-- VIEW FORCE TEST (구조는 만들어진다. 조회, DESC 사용하기 힘들다)
SELECT * FROM EMP15;
CREATE OR REPLACE FORCE VIEW VIEW_NOTABLE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMP15;
SELECT * FROM USER_VIEWS;
SELECT * FROM VIEW_NOTABLE;
-- VIEW WITH CHECK OPTION 
SELECT * FROM EMP01;
INSERT INTO EMP01
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, DEPARTMENT_ID 
FROM EMPLOYEES 
WHERE EMPLOYEE_ID <> 100
AND DEPARTMENT_ID IS NOT NULL;
SELECT * FROM VIEW_NOTABLE;

-- VIEW WITH CHECK OPTION
-- VIEW_CHK 만들고, 20번 부서에서 사원번호, 이름, 월급, 부서아이디
-- 20번 부서아이디 WITH CHECK OPTION 설정할 것 (수정 불가, 삭제 가능)
CREATE OR REPLACE VIEW VIEW_CHK
AS
SELECT EMPNO, EMP_NAME, EMP_JOB, DEP_ID
FROM EMP01 WHERE DEP_ID = 20 WITH CHECK OPTION;
SELECT * FROM VIEW_CHK;
UPDATE VIEW_CHK SET DEP_ID = 30 WHERE DEP_ID = 20;
SELECT * FROM VIEW_CHK;
UPDATE VIEW_CHK SET EMP_NAME = 'KDJ'
WHERE EMPNO = 201;
DELETE FROM VIEW_CHK WHERE DEP_ID = 20;

-- VIEW WITH READ ONLY : 기본테이블의 어떤 컬럼에도 내용을 절대 변경할 수 없도록 설정한다.
-- VIEW_READ 생성 후 EMP01에서 부서 30번을 아이디, 이름, 직급, 부서아이디를 출력하시오.
CREATE OR REPLACE VIEW VIEW_READ
AS 
SELECT EMPNO, EMP_NAME, EMP_JOB, DEP_ID 
FROM EMP01
WHERE DEP_ID = 30 WITH READ ONLY; 
SELECT * FROM VIEW_READ;
UPDATE VIEW_READ SET DEP_ID = 100 WHERE EMPNO = 114;

-- ROWNUM 확인하기 (페이징 기법)
-- ROWNUM 고용한 날짜 오래된 순으로 10명만 보여주시오
-- 가상뷰
DROP VIEW VIEW_HIREDATE_ASC;
CREATE OR REPLACE VIEW VIEW_HIREDATE_ASC
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE;
SELECT ROWNUM, FIRST_NAME, HIRE_DATE FROM VIEW_HIREDATE_ASC WHERE ROWNUM <= 10;
-- 인라인뷰(TOP-N)
SELECT ROWNUM, FIRST_NAME, HIRE_DATE 
FROM (SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE)
WHERE ROWNUM <= 10;

-- SEQUENCE 생성하기 EMP_SEQ 생성 시작값 1, 증가치 1, 최대값 무한대, 최소값 1, NOCYCLE, CACHE 2;
CREATE SEQUENCE EMP_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
NOMAXVALUE
NOCYCLE
CACHE 2;
DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, SALARY FROM EMPLOYEES WHERE 1 = 0;

-- SEQUENCE(AUTO INCREMENT) 사용하여 데이터 입력
INSERT INTO EMP01 VALUES(EMP_SEQ.NEXTVAL,'KKK',SYSDATE,40000);
INSERT INTO EMP01 VALUES(EMP_SEQ.NEXTVAL,'KKK2',SYSDATE,30000);
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME FROM EMP01;

-- SEQUENCE 현재 몇번까지 번호 설정되어 있는지 보는법
SELECT EMP_SEQ.CURRVAL FROM DUAL;

-- SEQUENCE 생성 DEV_SEQ, 시작 값 10, 증가치 10, 최소값 10, 최대값 30, NOCYCLE, CACHE2
DROP SEQUENCE DEP_SEQ;
CREATE SEQUENCE DEP_SEQ
START WITH 10
INCREMENT BY 10
MINVALUE 10
MAXVALUE 30
NOCYCLE 
CACHE 2;

-- DEP01 테이블 생성
DROP TABLE DEP01;
CREATE TABLE DEP01
AS
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID FROM DEPARTMENTS WHERE 1=0;

-- DEP01 DEP_SEQ 적용해서 데이터 삽입을 하는데 오류발생
INSERT INTO DEP01 VALUES(DEP_SEQ.NEXTVAL, '행정', 1);
INSERT INTO DEP01 VALUES(DEP_SEQ.NEXTVAL, '서무', 2);
INSERT INTO DEP01 VALUES(DEP_SEQ.NEXTVAL, '총무', 3);
INSERT INTO DEP01 VALUES(DEP_SEQ.NEXTVAL, '교육', 4);
SELECT * FROM DEP01;

-- DATA DICTIONARY SEQUENCE 참조
SELECT * FROM USER_SEQUENCES;

-- DEP_SEQ 수정 요청
ALTER SEQUENCE DEP_SEQ 
MAXVALUE 100;

-- 인덱스 설정
DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT * FROM EMPLOYEES;
SELECT * FROM EMP01;

-- DATA DICTIONARY(오라클에서 데이터베이스 관련 정보를 관리하는 테이블)
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONS_COLUMNS;
SELECT * FROM USER_IND_COLUMNS WHERE TABLE_NAME = 'EMP01';

SELECT * FROM EMP01 WHERE EMPLOYEE_ID = 200;
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = 200;

-- EMP01 EMPLOYEE_ID 인덱스 설정
CREATE UNIQUE INDEX IDX_EMP01_EMPLOYEEID
ON EMP01(EMPLOYEE_ID);

-- PL/SQL
DECLARE
    EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE; -- 레퍼런스 변수(객체참조변수)
    EMP_NAME EMPLOYEES.FIRST_NAME%TYPE;
BEGIN
    SELECT EMPLOYEE_ID, FIRST_NAME INTO EMP_ID, EMP_NAME FROM EMPLOYEES WHERE MANAGER_ID IS NULL;
    DBMS_OUTPUT.PUT_LINE('당신의 ID은: '|| EMP_ID || ' 당신의 이름은: ' || EMP_NAME); 
END;
/

-- 테이블 타입 정의해서 활용(배열) INT[]
-- TYPE KDJ TO INTEGER
-- INTEGER NO;
-- KDJ NO;
DECLARE
    EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE; -- 스칼라 변수, 레퍼런스 변수(객체참조변수)
    EMP_NAME EMPLOYEES.FIRST_NAME%TYPE;
BEGIN
    SELECT EMPLOYEE_ID, FIRST_NAME INTO EMP_ID, EMP_NAME FROM EMPLOYEES WHERE MANAGER_ID IS NULL;
    DBMS_OUTPUT.PUT_LINE('당신의 ID은: '|| EMP_ID || ' 당신의 이름은: ' || EMP_NAME); 
END;
/