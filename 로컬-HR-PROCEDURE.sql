-- <실습하기1> 입고 트리거 작성하기
-- 1. 상품 테이블 생성.
DROP TABLE PRODUCT;
CREATE TABLE PRODUCT(
    PCODE CHAR(6),
    PNAME VARCHAR(12) NOT NULL,
    PCOMPANY VARCHAR(12),
    PPRICE NUMBER(8),
    STOCK NUMBER DEFAULT 0,
    CONSTRAINT PRODUCT_PK PRIMARY KEY(PCODE)
);

-- 2. 입고 테이블을 생성
DROP TABLE RECEIVING;
CREATE TABLE RECEIVING(
    RNO NUMBER(6),
    PCODE CHAR(6),
    REDATE DATE DEFAULT SYSDATE,
    RQTY NUMBER(6),
    RPRICE NUMBER(8),
    RAMOUNT NUMBER(8),
    CONSTRAINT RECEIVING_PK PRIMARY KEY(RNO),
    CONSTRAINT RECEIVING_FK FOREIGN KEY(PCODE) REFERENCES PRODUCT(PCODE)
);

-- 3. 상품테이블의 재고수량 컬럼을 톻애서 실질적인 트리거의 적용 예를 살펴보도록 하겠다.
-- 우선 상품 테이블에 다음과 같은 샘플 데이터를 입력해보자.
INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE) VALUES('A00001', '세탁기', 'LG', 1500000);
INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE) VALUES('A00002', '컴퓨터', 'LG', 1000000);
INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE) VALUES('A00003', '냉장고', '삼성', 4500000);
SELECT * FROM PRODUCT;

-- 4. 입고 테이블에 상품이 입력되면 입고 수량을 테이블의 제고 수량에 추가하는 트리거 작성.
DROP TRIGGER TRG_IN;
CREATE OR REPLACE TRIGGER TRG_IN
AFTER INSERT ON RECEIVING
FOR EACH ROW
BEGIN 
    UPDATE PRODUCT
    SET STOCK = STOCK + :NEW.RQTY
    WHERE PCODE = :NEW.PCODE;
END;
/

-- 5. 트리거를 실행시킨 후 입고 테이블에 행을 추가한다. 입고 테이블에는 물론 상품 테이블의 재고 수량
-- 이 변경됨을 확인할 수 있다.
INSERT INTO RECEIVING(RNO, PCODE, RQTY, RPRICE, RAMOUNT)
VALUES(1, 'A00001', 5, 850000, 950000);
SELECT * FROM RECEIVING;
SELECT * FROM PRODUCT;

-- 6. 입고 테이블에 상품이 입력되면 자동으로 상품 테이블의 재고 수량이 증가하게 된다. 
-- 입고 테이블에 또 다른 상품을 입력한다.
INSERT INTO RECEIVING(RNO, PCODE, RQTY, RPRICE, RAMOUNT)
VALUES(2, 'A00002', 10, 680000, 780000);
SELECT * FROM PRODUCT;

INSERT INTO RECEIVING(RNO, PCODE, RQTY, RPRICE, RAMOUNT)
VALUES(3, 'A00003', 10, 250000, 300000);
SELECT * FROM RECEIVING;

-- <실습하기2> 갱신 트리거 작성하기
-- 1. 갱신 트리거 생성
DROP TRIGGER TRG_UP;
CREATE OR REPLACE TRIGGER TRG_UP
AFTER UPDATE ON RECEIVING
FOR EACH ROW
BEGIN 
    UPDATE PRODUCT
    SET STOCK = STOCK + (-:old.RQTY+:new.RQTY)
    WHERE PCODE = :new.PCODE;
END;
/

-- 2. 입고 번호 3번은 냉장고가 입고된 정보를 기록한 것으로서 입고 번호 3번의 입고수량을
-- 8로 변경하였더니 냉장고의 재고 수량 역시 8로 변경되었다.
UPDATE RECEIVING SET RQTY = 8, RAMOUNT = 280000 WHERE RNO = 3;
SELECT * FROM RECEIVING;
SELECT * FROM PRODUCT;

-- <실습하기1> 삭제 트리거 작성하기
-- 1. 삭제 트리거 생성.
DROP TRIGGER TRG_DEL;
CREATE OR REPLACE TRIGGER TRG_DEL
AFTER DELETE ON RECEIVING
FOR EACH ROW
BEGIN 
    UPDATE PRODUCT
    SET STOCK = STOCK - :old.RQTY
    WHERE PCODE = :old.PCODE;
END;
/

-- 2. 입고 번호 3번은 냉장고가 입고된 정보를 기록한 것으로서 입고 번호가 3번인 행을 삭제하였더니
-- 냉장고의 재고 수량 역시 0으로 변경되었다.
DELETE RECEIVING WHERE RNO = 3;
SELECT * FROM PRODUCT;

-- [예제] 
-- 오라클에서 성적처리 테이블을 생성하라.
DROP TABLE SUNG;
CREATE TABLE SUNG(
    HAKBUN NUMBER(4),
    HAKNAME VARCHAR2(20) NOT NULL,
    KOR NUMBER(4) NOT NULL,
    ENG NUMBER(4) NOT NULL,
    MAT NUMBER(4) NOT NULL,
    TOT NUMBER(4),
    AVE NUMBER(5,1),
    RANK NUMBER(4)
);
ALTER TABLE SUNG ADD CONSTRAINT SUNG_PK PRIMARY KEY(HAKBUN);
SELECT * FROM SUNG;
-- 2. 테이블에 학번, 이름, 국어, 영어, 수학 점수를 입력하면 총점과 평균이 자동 계산되어 입력되도록
-- 프로시저(SUNG_INPUT)를 작성하라.
CREATE OR REPLACE PROCEDURE SUNG_INPUT(
HAK IN SUNG.HAKBUN%TYPE, HAKNAME IN SUNG.HAKNAME%TYPE, KOR IN SUNG.KOR%TYPE,
ENG IN SUNG.ENG%TYPE, MAT IN SUNG.MAT%TYPE
)
IS 
BEGIN
   UPDATE SUNG SET TOT = (KOR + ENG +MAT), AVE = ROUND((KOR + ENG + MAT) / 3,2) WHERE HAKBUN = HAK;
END;
/
INSERT INTO SUNG VALUES(1, '홍길동', 99, 80, 85, NULL, NULL, NULL);
EXECUTE SUNG_INPUT(1, '홍길동', 99, 80, 85);
SELECT * FROM SUNG;
-- 3. 테이블에 학번, 이름, 국어, 영어, 수학 점수를 입력하면 총점과 평균이 자동 계산되도록 
-- 트리거(SUNGCAL_TRG)를 작성하라.
DROP TRIGGER SUNGCAL_TRG;
CREATE OR REPLACE TRIGGER SUNGCAL_TRG
BEFORE INSERT ON SUNG
FOR EACH ROW 
BEGIN
    :NEW.TOT := :NEW.KOR + :NEW.ENG + :NEW.MAT;
    :NEW.AVE := ROUND((:NEW.KOR + :NEW.ENG + :NEW.MAT)/3,2);
    DBMS_OUTPUT.PUT_LINE('학생성적 정보가 입력되었습니다.');
END;
/
SHOW ERROR;
INSERT INTO SUNG(HAKBUN, HAKNAME, KOR, ENG, MAT) VALUES(2, '김희진', 95, 84, 79);
INSERT INTO SUNG(HAKBUN, HAKNAME, KOR, ENG, MAT) VALUES(3, '이현수', 83, 89, 99);
SELECT * FROM SUNG;
-- 4. 등수(SUNG_RANK)를 구하는 저장프로시저를 작성하고 이를 호출하여 등수가 제대로 구해지는지 확인
-- 하자. 다음은 등수를 구하는 저장프로시저 SP_RANK가 성공적으로 작성되었다는 가정 하에 실습한 결과이다.
INSERT INTO SUNG(HAKBUN, HAKNAME, KOR, ENG, MAT) VALUES(4, '김철수', 99, 83, 89);
INSERT INTO SUNG(HAKBUN, HAKNAME, KOR, ENG, MAT) VALUES(5, '조현정', 80, 75, 88);
DROP PROCEDURE SUNG_RANK;

EXECUTE SUNG_RANK;
SELECT HAKBUN, HAKNAME, KOR, ENG, MAT, TOT, AVE FROM SUNG ORDER BY RANK ASC, KOR DESC, ENG DESC, MAT DESC;
