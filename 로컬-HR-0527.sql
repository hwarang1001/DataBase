-- DEPT1 테이블 생성 및 데이터 입력
-- 부모테이블에서 참조된 기본키값을 변경하거나 삭제를 진행할 때에는 
-- 자식테이블에 참조키를 NULL 수정하거나, 해당된 튜플을 삭제하면 된다.
CREATE TABLE DEPT01(
    DEPTNO NUMBER(2),   
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13),
    CONSTRAINT DEPT01_PK PRIMARY KEY(DEPTNO) 
);
INSERT INTO DEPT01 VALUES(10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT01 VALUES(20, 'RESEARCH', 'DALLAS');
INSERT INTO DEPT01 VALUES(30, 'DEVELOPMENT', 'KOREA');
SELECT * FROM DEPT01;
UPDATE DEPT01 SET DEPTNO = 40 WHERE DEPTNO = 10;
DELETE FROM DEPT01 WHERE DEPTNO = 10;

-- EMP01 테이블 생성, 데이터 입력
-- (자식: 아무 문제 없다. 단 UPDATE할때 없는 부모키를 참조하면 오류), NULL 다른키로 UPDATE가능
CREATE TABLE EMP01(
    EMPNO NUMBER(4), -- 제약조건1(PK)
    ENAME VARCHAR2(10) NOT NULL, -- 제약조건2(NN)
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4), -- 제약조건3(FK): 참조테이블 주의 UPDATE, DELETE
    PRIMARY KEY(EMPNO),
    FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO)
);
INSERT INTO EMP01 VALUES(7499, 'ALLEN', 'SALESMAN', 10);
INSERT INTO EMP01 VALUES(7369, 'SMITH', 'CLERK', 20);
ALTER TABLE EMP01 ADD CONSTRAINT EMP01_DEPT01_DEPTNO_FK FOREIGN KEY(DEPTNO)
REFERENCES DEPT01(DEPTNO) ON DELETE CASCADE;
SELECT * FROM EMP01;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP01';
UPDATE EMP01 SET DEPTNO = 40 WHERE DEPTNO = 10;

-- CROSS JOIN (107 * 27)
SELECT * FROM EMPLOYEES; -- 107
SELECT * FROM DEPARTMENTS; -- 27
SELECT COUNT(*) FROM EMPLOYEES, DEPARTMENTS; -- 107 * 27 = 2889
--CROSS JOIN (ANSI CROSS JOIN)
SELECT COUNT(*) FROM EMPLOYEES CROSS JOIN DEPARTMENTS; -- 107 * 27 = 2889

-- INNER JOIN (PK:부모, 참조테이블 = FK:자식, 기본테이블)
SELECT * FROM EMPLOYEES; -- 107
SELECT * FROM DEPARTMENTS; -- 27
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME FROM EMPLOYEES E, DEPARTMENTS D 
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND UPPER(E.FIRST_NAME) = UPPER('SUSAN');
-- INNER JOIN (ANSI JOIN)
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME FROM EMPLOYEES E INNER JOIN DEPARTMENTS D 
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID  WHERE UPPER(E.FIRST_NAME) = UPPER('SUSAN');
-- INNER JOIN (ANSI JOIN USING) 기본키 속성명과 참조키 속성명이 같을 경우 사용자 이름, 부서 아이디, 부서명을 출력하시오.
-- ON 을 사용하지 말 것, 별칭은 사용하되 USING으로 사용된 속성명에는 별칭을 붙이지 말 것
SELECT FIRST_NAME AS "사용자 이름", DEPARTMENT_ID AS "부서 아이디", DEPARTMENT_NAME AS "부서명"
FROM EMPLOYEES INNER JOIN DEPARTMENTS USING(DEPARTMENT_ID);
-- NON-EQUAL JOIN ('=' 연산자를 사용하지 않는다.(FOREIGN KEY가 없다.))
CREATE TABLE SALARYGRADE(
    GRADE NUMBER,
    MINSALARY NUMBER,
    MAXSALARY NUMBER
);
INSERT INTO SALARYGRADE VALUES (1, 2000, 3000);
INSERT INTO SALARYGRADE VALUES (2, 3001, 4500);
INSERT INTO SALARYGRADE VALUES (3, 4501, 6000);
INSERT INTO SALARYGRADE VALUES (4, 6001, 8000);
INSERT INTO SALARYGRADE VALUES (5, 8001, 10000);
INSERT INTO SALARYGRADE VALUES (6, 10001, 13000);
INSERT INTO SALARYGRADE VALUES (7, 13001, 20000);
INSERT INTO SALARYGRADE VALUES (8, 20001, 30000);
SELECT E.FIRST_NAME, E.SALARY, S.GRADE FROM EMPLOYEES E, SALARYGRADE S
WHERE E.SALARY BETWEEN S.MINSALARY AND S.MAXSALARY;

-- OUTER JOIN = INNER JOIN (PK, FK) = LEFT OUTER JOIN, RIGHT OUTER JOIN, BOTH OUTER JOIN
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME FROM EMPLOYEES E, DEPARTMENTS D 
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID; -- (+)는 널로 채워준다.
-- OUTER JOIN (ANSI OUTER JOIN)
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME 
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D 
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 2007년도 상반기에 입사한 사원을 조사해라.
SELECT E.EMPLOYEE_ID,E.FIRST_NAME, E.SALARY, E.HIRE_DATE, D.DEPARTMENT_NAME 
FROM EMPLOYEES E, DEPARTMENTS D 
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
AND (E.HIRE_DATE BETWEEN '07/01/01' AND '07/06/30');

-- SELF JOIN (한개 테이블을 두개 테이블로 만들어 조인) PK, 선언 되지 않은 FK 생각할 것
SELECT * FROM EMPLOYEES;
SELECT E2.EMPLOYEE_ID 사원아이디, E2.FIRST_NAME 사원이름, E2.SALARY 사원월급, E1.EMPLOYEE_ID 상사아이디,
E1.FIRST_NAME 상사이름, E1.SALARY 상사월급 FROM EMPLOYEES E1, EMPLOYEES E2 
WHERE E1.EMPLOYEE_ID = E2.MANAGER_ID;

SELECT E2.FIRST_NAME|| '사원의 상사 이름은' || E1.FIRST_NAME || '입니다.'
FROM EMPLOYEES E1, EMPLOYEES E2 
WHERE E1.EMPLOYEE_ID = E2.MANAGER_ID;

-- ROWNUM (번호 자동설정 진행이 된다.) 10개만 보고 싶다. 
SELECT * FROM EMPLOYEES WHERE ROWNUM <= 10;
-- SALARY 제일 많이 받는 사람순으로 10명만 출력하시오. FIRST_NAME, SALARY 구해보시오.
SELECT FIRST_NAME, SALARY FROM (SELECT * FROM EMPLOYEES ORDER BY SALARY DESC)
WHERE ROWNUM <= 10;