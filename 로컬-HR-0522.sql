SELECT * FROM TAB;
-- 테이블 구조를 볼 수 있다.
DESCRIBE TAB;  
DESC EMPLOYEES;
-- EMPLOYEES 테이블 전체내용
SELECT * FROM EMPLOYEES;
-- ID, NAME, EMAIL 내용선택 출력(별칭 사용)
SELECT EMPLOYEE_ID AS 아이디, FIRST_NAME AS 이름, LAST_NAME AS 성, EMAIL AS 이메일 FROM EMPLOYEES;
SELECT EMPLOYEE_ID 아이디, FIRST_NAME 이름, LAST_NAME 성, EMAIL 이메일 FROM EMPLOYEES;
SELECT EMPLOYEE_ID AS "회사 아이디", FIRST_NAME AS 이름, LAST_NAME AS 성, EMAIL AS 이메일 FROM EMPLOYEES;
-- EMPLOYEES테이블 ID가 107번 사원만 출력 (IF == WHERE)
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = 107;
-- EMPLOYEES테이블 ID가 107번 110번 사원만 출력 (IF == WHERE)
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID >= 107 AND EMPLOYEE_ID <= 110;
-- EMPLOYEES테이블 이름이 D로 시작되는 사원만 출력 (IF == WHERE)
SELECT * FROM EMPLOYEES WHERE FIRST_NAME LIKE '%h';
-- '_D%', '_D_F%', '%D%', '%D' 

-- EMPLOYEES 이름과 직급을 출력하시오. "ELLEN 님의 직급은 매니저입니다."
SELECT FIRST_NAME || '님의 직급은' || JOB_ID || '매니저 입니다.' AS MESSAGE FROM EMPLOYEES;
-- EMPLOYEES 직급을 출력하시오. (중복 하지 말고)
SELECT DISTINCT JOB_ID FROM EMPLOYEES;
SELECT JOB_ID FROM EMPLOYEES;
SELECT JOB_ID, COUNT(*) "직급별 카운트" FROM EMPLOYEES GROUP BY JOB_ID HAVING COUNT(*) >= 20;
SELECT * FROM EMPLOYEES;
-- NULL은 비교 대상이 되지 않는다.
SELECT EMPLOYEE_ID, FIRST_NAME, COMMISSION_PCT, JOB_ID 
FROM EMPLOYEES 
WHERE COMMISSION_PCT IS NOT NULL;
-- 사번을 기준으로 내림차순으로 정렬, 연봉은 오름차순 2차정렬이상 처리된다.
SELECT JOB_ID, SALARY FROM EMPLOYEES ORDER BY JOB_ID DESC, SALARY ASC;
-- 가상테이블 => 진짜테이블(인스턴스 1개 있는 테이블, 컬럼명 1개)
SELECT 24+34 AS RESULT FROM DUAL;
DESC DUAL;
SELECT * FROM DUAL;
-- GROUP BY : 2개이상이 나와야 그룹대상
-- 부서별 총급여를 구하시오.
SELECT DEPARTMENT_ID, SUM(SALARY) FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID HAVING SUM(SALARY) >= 50000 AND DEPARTMENT_ID = 100;

-- JOB_ID : IT_PROG 문자열을 비교할 때에는 UPPER(), LOWER()
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID FROM EMPLOYEES
WHERE LOWER(JOB_ID) = LOWER('IT_PROg');
-- CONCAT(인수는 2개까지 허용)
SELECT CONCAT(FIRST_NAME, '($' || SALARY || ')') AS "사원 정보" FROM EMPLOYEES
WHERE DEPARTMENT_ID = 30;
-- 입사년도에 월만 출력 
SELECT FIRST_NAME, HIRE_DATE, SUBSTR(HIRE_DATE,4,2) AS "입사 월" FROM EMPLOYEES
WHERE DEPARTMENT_ID = 20;
-- 현재 날짜를 출력
SELECT SYSDATE-1 AS "어제 날짜", SYSDATE AS "현재 날짜", SYSDATE+1 AS "내일 날짜" FROM DUAL;
-- EMPLOYEES 에서 30번 부서에 사원의 입사년도부터 현재날짜까지 근무개월 수 구하기
SELECT FIRST_NAME, SYSDATE 오늘, TO_CHAR(HIRE_DATE, 'YYYY/MM/DD') 입사일,
TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) 근무달수 FROM EMPLOYEES
WHERE DEPARTMENT_ID = 30;
-- 현재 날짜에 '2025/04/24' 날짜를 빼서 계산
SELECT CONCAT(TRUNC(SYSDATE - TO_DATE('2025/04/24','YYYY/MM/DD')),'일') "뺀 날짜" FROM DUAL;
-- 문자열 + 문자열 => 오류
SELECT CONCAT('10,000', '20,000') FROM DUAL;
SELECT TO_NUMBER('10,000', '999,999') + TO_NUMBER('20,000', '999,999') FROM DUAL;
-- EMPLOYEES에서 직급별 정렬(오름차순) 이름, 봉급, 인상률, 보너스 금액, 월급 + 보너스 금액
SELECT FIRST_NAME, SALARY, COMMISSION_PCT, SALARY * NVL(COMMISSION_PCT,0) AS COMMISSION,
SALARY + (SALARY * NVL(COMMISSION_PCT, 0)) AS TOTAL, JOB_ID FROM EMPLOYEES ORDER BY JOB_ID;
-- NVL2(컬럼, NULL이 아니면, NULL이면)
SELECT FIRST_NAME, SALARY, COMMISSION_PCT, NVL2(COMMISSION_PCT, SALARY+(SALARY*NVL(COMMISSION_PCT, 0)), SALARY)
AS TOTAL, JOB_ID FROM EMPLOYEES ORDER BY JOB_ID;
-- SWITCH CASE 역할을 하는 DECODE함수
SELECT DISTINCT DEPARTMENT_ID, 
DECODE(DEPARTMENT_ID, 
10, 'Administration', 
20, 'Marketing', 
30, 'Purchasing', 
40, 'Human Resources', 
50, 'Shipping', 
60, 'IT' ) 
AS DEPARTMENTS FROM EMPLOYEES ORDER BY DEPARTMENT_ID;
-- GROUP BY SUM, AVG, MAX, MIN, COUNT
SELECT COUNT(*) AS TOTAL FROM EMPLOYEES;
-- COUNT(*) NULL 연산, 비교, 카운트 값은 인정하지 않는다.
SELECT COUNT(COMMISSION_PCT) AS TOTAL FROM EMPLOYEES;
-- 부서별로 월급 평균을 구하시오.
SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2) AS "부서별 평균연봉", MAX(SALARY) AS "부서별 최고연봉",
MIN(SALARY) AS "부서별 최소연봉", COUNT(*) AS "부서별 인원" FROM EMPLOYEES GROUP BY DEPARTMENT_ID;
-- EMPLOYEES 에서 부서별로 최대급여, 최소급여 보여주되, 부서별 정렬(기본값: ASC)
SELECT DEPARTMENT_ID, MAX(SALARY) 최대급여, MIN(SALARY) 최소급여 FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID ORDER BY DEPARTMENT_ID ASC;
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID IS NULL;
-- ROLLUP은 GROUP BY를 부분항목별로 통계를 해줄 것
SELECT DEPARTMENT_ID, JOB_ID, MAX(SALARY), MIN(SALARY), TRUNC(AVG(SALARY)), 
COUNT(*), SUM(SALARY) FROM EMPLOYEES GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID) 
ORDER BY DEPARTMENT_ID ASC, JOB_ID ASC;
-- CUBE ROLLUP 합계
SELECT DEPARTMENT_ID, JOB_ID, MAX(SALARY), MIN(SALARY), TRUNC(AVG(SALARY)), 
COUNT(*), SUM(SALARY) FROM EMPLOYEES GROUP BY CUBE(DEPARTMENT_ID, JOB_ID) 
ORDER BY DEPARTMENT_ID ASC, JOB_ID ASC;
-- 새 테이블 생성 DEPT 속성(DEPTNO, DNAME, LOC) NOT NULL(모두), PK(DEPTNO)
CREATE TABLE DEPT(
    DEPTNO NUMBER(4),
    DNAME VARCHAR2(20) NOT NULL,
    LOC VARCHAR2(20) NOT NULL
);
ALTER TABLE DEPT ADD CONSTRAINT DEPT_PK PRIMARY KEY(DEPTNO);
ALTER TABLE DEPT DROP CONSTRAINT DEPT_PK;
ALTER TABLE DEPT MODIFY DNAME VARCHAR2(20);
ALTER TABLE DEPT ADD DPHONE VARCHAR2(12);
ALTER TABLE DEPT DROP COLUMN DPHONE;
ALTER TABLE DEPT MODIFY LOC VARCHAR2(20) NULL;
--INSERT
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(1,'컴퓨터학과','본관');
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(2,'시스템학과','공학관');
INSERT INTO DEPT VALUES(3,'컴공','공학관2');
INSERT INTO DEPT(DEPTNO, DNAME) VALUES(4,'디자인');
INSERT INTO DEPT VALUES(5,'컴디',NULL);
--SELECT 
SELECT * FROM DEPT;
DESC DEPT;
-- 기존 테이블에 데이터만 다른 테이블에 있는 내용을 가져오고 싶을 때 
INSERT INTO DEPT 
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID FROM DEPARTMENTS;
-- 새 테이블 생성(개-논-물 INSERT INTO 테이블명(컬럼명) VALUES() WHERE(없다)) 50번 반복해야한다.
-- 다른 테이블에 이러한 구조가 있는데, 삽입, 수정, 삭제 빈번히 일어나야된다. 
-- 제약조건은 복사를 하지 못한다.
CREATE TABLE EMP
AS SELECT * FROM EMPLOYEES;
SELECT * FROM EMP;
DESC EMP;
-- EMP EMLOYEE_ID PK 지정하라 ALTER~
ALTER TABLE EMP ADD CONSTRAINT EMP_PK PRIMARY KEY(EMPLOYEE_ID);
-- EMP 부서번호 90 => 91번으로 변경하세요.
UPDATE EMP SET DEPARTMENT_ID = 91 WHERE DEPARTMENT_ID = 90;
COMMIT;
ROLLBACK;
-- EMP 에서 91부서들만 봉급 10% 인상률
UPDATE EMP SET SALARY = ROUND(SALARY * 1.1) WHERE DEPARTMENT_ID = 91;
ROLLBACK;
-- EMP 에서 사원이름 SUSAN 사람을 부서를 20, 직급을 FI_MGR
UPDATE EMP SET DEPARTMENT_ID = 20, JOB_ID = 'FI_MGR' WHERE UPPER(FIRST_NAME) = 'SUSAN';
SELECT * FROM EMP WHERE UPPER(FIRST_NAME) = 'SUSAN';
-- EMP 에서 부서 20번 직원들만 삭제
DELETE FROM EMP WHERE DEPARTMENT_ID = 20;
SELECT * FROM EMP WHERE DEPARTMENT_ID = 20;